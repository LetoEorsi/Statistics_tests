Swiss1 <- read.table("Документы/R/R2/Swiss_Bank_Notes_R", header=T, sep=",")
fake <-c(rep(0,100),rep(1,100))
Swiss2 <- data.frame(Swiss1,fake)
Swiss2$fake <- as.factor(Swiss2$fake)
#hist(Swiss2$Length[Swiss2$fake==1],n=20)
#library(ggplot2)
#ggplot(Swiss2, aes(x=Diag, y=dist.l,colour=fake))+
#geom_point()

#Предположим нормальное распределение параметров подлиных и фальшивых банкнот
#Вычислим для них оценки метода максимального правдоподобия

Swiss.learn.G <- data.frame(Swiss2[1:50,c(1:6)]) #Выделим дата-фрейм с подлинными банкнотами
Swiss.learn.F <- data.frame(Swiss2[101:150,c(1:6)]) #Выделим дата-фрейм с поддельными банкнотами

mean.g <- colSums(Swiss.learn.G)/50 #Оценки для среднего
mean.f <- colSums(Swiss.learn.F)/50 

Cov.G=diag(1:6)
Cov.F=diag(1:6)


for(i in 1:6){ #Оценки для матрицы ковариаций
  for(j in 1:6){
      Cov.G[i,j] <- 1/50*t(Swiss.learn.G[,i])%*%Swiss.learn.G[,j]
      Cov.F[i,j] <- 1/50*t(Swiss.learn.F[,i])%*%Swiss.learn.F[,j]
  }
}

#Теперь у нас есть 2 распределения: подлинных и поддельных банкнот, и мы хотим придумать критерий, который их различает эти две возможности.
#Запишем теперь формально: Нулевая гипотеза -- банкнота поддельна, альтернативная -- подлинная. Этот выбор обоснован тем, что мы не хотим ошибаться
# с поддельным купюрами, то есть это должна быть ошибка первого рода. 

#Попробуем применить РНМ-критерий Неймана-Пирсона

#Выпишем функцию правдоподобия для подлинных купюр
LikehoodFunc.G <- function(x){
  S=solve(Cov.G)%*%t(x-mean.g);
  L=1/((determinant(Cov.G)$modulus)^(1/2)*(2*pi)^3)*exp(-1/2*data.matrix(x-mean.g)%*%(S))
}

#Выпишем функцию правдоподобия для поддельных купюр
LikehoodFunc.F <- function(x){
  S=solve(Cov.F)%*%t(x-mean.f); 
  L=1/((determinant(Cov.F)$modulus)^(1/2)*(2*pi)^3)*exp(-1/2*data.matrix(x-mean.f)%*%(S))
}

#И логарифм отношения функций правдоподобий

P <- function(x){
  m=dim(x)[1]
  S=rep(1:m)
  for(i in 1:m) {
    S[i]=log(LikehoodFunc.G(x[i,]))-log(LikehoodFunc.F(x[i,]))
  }
  return(S)
}

#Так как оба распределения имеют плотности, то критерий нерандомизирован. Но применить его явно 
#не получится -- точно вычислять критический уровень очень тяжело. Вместо этого поступим по-другому: рассмотрим это отношение
#на самих данных Swiss.G и Swiss.F,а критический уровень функции оценим через квантили получившихся рядов
#
#Если наша функция велика, то нулевая гипотеза отвергается и купюра принимается подлинной; если же функция мала, то купюра, возможно поддельная.

#Составим датасет из значений нашей функции на примерах купюр 
#fake=0 подлинная
#fake=1 подделка

Comp.test <- data.frame( Level=c(P(Swiss2[51:100,c(1:6)]),P(Swiss2[151:200,c(1:6)])), fake = c(rep(0,50),rep(1,50)))

#Два коробочных графика
boxplot(Level~fake,data=Comp.test)

G <-Comp.test[Comp.test[,2]==0,1]
F <-Comp.test[Comp.test[,2]==1,1]

#Минимум по подлинным купюрам
min(G)
#Максимум по поддельным
max(F)

#Но квантили разительно отличаются:
quantile(G,probs = c(0.005,0.95))
quantile(F,probs = c(0.05,0.95))



#1%-квантиль снизу на подлинные купюры = 9.82, при этом максимум по поддельным -2.45
#Так что можно отвергать нулевую гипотезу(купюра поддельная) для купюр с P>9.82

NPCrit <- function(x){
  return(P(x)>9.82)
}
